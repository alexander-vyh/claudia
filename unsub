#!/usr/bin/env node
/**
 * OpenClaw Automated Unsubscribe
 * Fully automated email unsubscribe using Gmail API
 */

const fs = require('fs');
const { google } = require('googleapis');
const https = require('https');
const http = require('http');
const { URL } = require('url');
const { execSync } = require('child_process');

const config = require('./lib/config');
const CREDENTIALS_PATH = process.env.HOME + '/.openclaw/gmail-credentials.json';
const TOKEN_PATH = process.env.HOME + '/.openclaw/gmail-token.json';
const GMAIL_ACCOUNT = config.gmailAccount;

// Parse --correlation-id from args (passed by gmail-monitor)
const correlationArg = process.argv.find(a => a.startsWith('--correlation-id='));
const correlationId = correlationArg ? correlationArg.split('=')[1] : undefined;
const log = require('./lib/logger')('unsub', { correlationId });

/**
 * Get authorized Gmail client
 */
function getGmailClient() {
  const credentials = JSON.parse(fs.readFileSync(CREDENTIALS_PATH));
  const { client_secret, client_id, redirect_uris } = credentials.installed;

  const oAuth2Client = new google.auth.OAuth2(
    client_id,
    client_secret,
    redirect_uris[0]
  );

  if (!fs.existsSync(TOKEN_PATH)) {
    log.error('Not authorized yet. Run: node gmail-auth.js');
    process.exit(1);
  }

  const token = JSON.parse(fs.readFileSync(TOKEN_PATH));
  oAuth2Client.setCredentials(token);

  return google.gmail({ version: 'v1', auth: oAuth2Client });
}

/**
 * Search for email using gog (faster than API for search)
 */
function searchEmail(query) {
  try {
    const result = execSync(
      `gog gmail messages search "${query}" --account ${GMAIL_ACCOUNT} --max 1 --json`,
      { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'ignore'] }
    );
    const data = JSON.parse(result);
    return data.messages?.[0]?.id || null;
  } catch (error) {
    return null;
  }
}

/**
 * Get full email via Gmail API
 */
async function getEmail(gmail, emailId) {
  const res = await gmail.users.messages.get({
    userId: 'me',
    id: emailId,
    format: 'full'
  });
  return res.data;
}

/**
 * Recursively collect all MIME parts from a Gmail message payload
 */
function flattenParts(part) {
  if (part.parts) {
    return part.parts.flatMap(flattenParts);
  }
  return [part];
}

/**
 * Extract unsubscribe link from email
 */
function extractUnsubscribeLink(email) {
  const headers = email.payload.headers;

  // Check List-Unsubscribe header (RFC 2369)
  const listUnsub = headers.find(h => h.name.toLowerCase() === 'list-unsubscribe');
  if (listUnsub) {
    // Try HTTPS URL first (one-click unsubscribe)
    const httpsMatch = listUnsub.value.match(/<(https:\/\/[^>]+)>/);
    if (httpsMatch) {
      return { url: httpsMatch[1], method: 'one-click' };
    }

    // Try HTTP URL
    const httpMatch = listUnsub.value.match(/<(http:\/\/[^>]+)>/);
    if (httpMatch) {
      return { url: httpMatch[1], method: 'one-click' };
    }

    // Try mailto
    const mailtoMatch = listUnsub.value.match(/<mailto:([^>]+)>/);
    if (mailtoMatch) {
      return { mailto: mailtoMatch[1], method: 'mailto' };
    }
  }

  // Parse HTML body for unsubscribe link (recursively flatten MIME parts)
  const allParts = flattenParts(email.payload);
  for (const part of allParts) {
    if (part.mimeType === 'text/html' && part.body?.data) {
      const html = Buffer.from(part.body.data, 'base64').toString();

      // 1) URL itself contains "unsubscribe"
      const urlMatch = html.match(/<a[^>]+href=["']([^"']*unsubscribe[^"']*)["']/i);
      if (urlMatch) {
        return { url: urlMatch[1].replace(/&amp;/g, '&'), method: 'html-link' };
      }

      // 2) Link text contains "unsubscribe" (common with tracking URLs)
      const textMatch = html.match(/<a[^>]+href=["']([^"']+)["'][^>]*>[^<]*unsubscribe[^<]*/i);
      if (textMatch) {
        return { url: textMatch[1].replace(/&amp;/g, '&'), method: 'html-link-text' };
      }
    }
  }

  return null;
}

/**
 * Visit unsubscribe URL
 */
function visitUrl(urlString) {
  return new Promise((resolve, reject) => {
    const parsedUrl = new URL(urlString);
    const client = parsedUrl.protocol === 'https:' ? https : http;

    const options = {
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36'
      }
    };

    client.get(urlString, options, (res) => {
      let body = '';
      res.on('data', chunk => body += chunk);
      res.on('end', () => {
        // Check if we got redirected or need to confirm
        if (res.statusCode >= 200 && res.statusCode < 400) {
          resolve({ success: true, status: res.statusCode, body });
        } else {
          reject(new Error(`HTTP ${res.statusCode}`));
        }
      });
    }).on('error', reject);
  });
}

/**
 * Archive email after unsubscribe
 */
async function archiveEmail(gmail, emailId) {
  await gmail.users.messages.modify({
    userId: 'me',
    id: emailId,
    requestBody: {
      removeLabelIds: ['INBOX']
    }
  });
}

/**
 * Main unsubscribe workflow
 */
async function main() {
  const query = process.argv.slice(2).filter(a => !a.startsWith('--correlation-id=')).join(' ');
  if (!query) {
    log.error('Usage: unsub <search query | id:<gmail-message-id>>');
    process.exit(1);
  }

  let emailId;

  // Direct ID lookup (e.g. "id:19c2fed919be283b")
  const idMatch = query.match(/^id:(\S+)$/);
  if (idMatch) {
    emailId = idMatch[1];
    log.info({ emailId }, 'Using message ID directly');
  } else {
    log.info({ query }, 'Searching for email');
    emailId = searchEmail(query);
    if (!emailId) {
      log.error({ query }, 'No email found');
      process.exit(1);
    }
    log.info({ emailId }, 'Found email');
  }

  // Get Gmail client
  const gmail = getGmailClient();

  // Get full email
  log.info('Fetching email via Gmail API');
  const email = await getEmail(gmail, emailId);

  const from = email.payload.headers.find(h => h.name === 'From')?.value || 'Unknown';
  const subject = email.payload.headers.find(h => h.name === 'Subject')?.value || 'No subject';

  log.info({ from, subject }, 'Email retrieved');

  // Extract unsubscribe link
  log.info('Looking for unsubscribe link');
  const unsub = extractUnsubscribeLink(email);

  if (!unsub) {
    log.error({ from, subject }, 'No unsubscribe link found in email');
    process.exit(1);
  }

  log.info({ method: unsub.method }, 'Found unsubscribe link');

  if (unsub.mailto) {
    log.warn({ mailto: unsub.mailto }, 'Mailto unsubscribe requires manual action');
    execSync(`open "mailto:${unsub.mailto}"`);
    process.exit(1);
  }

  // Visit unsubscribe URL
  log.info({ url: unsub.url.substring(0, 80) }, 'Visiting unsubscribe URL');

  try {
    const result = await visitUrl(unsub.url);
    log.info({ status: result.status }, 'Unsubscribe request sent');

    // Archive the email
    log.info('Archiving email');
    await archiveEmail(gmail, emailId);
    log.info('Email archived');

    log.info({ from, subject }, 'Successfully unsubscribed');
  } catch (error) {
    log.error({ err: error, url: unsub.url }, 'Failed to unsubscribe, opening in browser');
    execSync(`open "${unsub.url}"`);
    process.exit(1);
  }
}

main().catch(error => {
  log.fatal({ err: error }, 'Unhandled error');
  process.exit(1);
});
